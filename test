local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Rayfield Example Window",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Rayfield Interface Suite",
   LoadingSubtitle = "by Sirius",
   Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Tab Example", 4483362458) -- Title, Image

local sigma = true

if sigma then
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

local animationBlockEnabled = false -- Variable to track if the toggle is enabled

-- Function to block the animation
local function onAnimationPlayed(animationTrack)
    if not animationBlockEnabled then
        return -- Do nothing if the toggle is off
    end

    local animationId = animationTrack.Animation.AnimationId
    local blockedAnimationId = "rbxassetid://10470389827"
    
    if animationId == blockedAnimationId then
        -- Stop the animation if it matches the blocked animation ID
        animationTrack:Stop()
        print("Blocked animation with ID:", animationId)
    end
end

-- Monitor animation tracks being added to the Humanoid
local function monitorAnimations()
    local humanoid = Character:WaitForChild("Humanoid")
    humanoid.AnimationPlayed:Connect(onAnimationPlayed)
end

-- Ensure the function runs even if the character respawns
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    monitorAnimations()
end)

-- Start monitoring animations
monitorAnimations()

-- Create the toggle
local Toggle = Tab:CreateToggle({
    Name = "Invisible Block",
    CurrentValue = false, -- Default value (off)
    Flag = "AnimationBlockToggle", -- Unique identifier for the toggle
    Callback = function(Value)
        animationBlockEnabled = Value -- Enable or disable the blocking
        print("Invisible Block is now", Value and "ON" or "OFF")
    end,
})
end

-- Function to perform the "SkidFling" action on the target player
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

-- Save original FallenPartsDestroyHeight
getgenv().FPDH = workspace.FallenPartsDestroyHeight

-- Get player by partial username or display name
function GetPlayer(Name)
	Name = Name:lower()
	for _, x in next, Players:GetPlayers() do
		if x ~= Player then
			if x.Name:lower():match("^" .. Name) or x.DisplayName:lower():match("^" .. Name) then
				return x
			end
		end
	end
end

-- Fling function with loop and ground check
function SkidFling(TargetPlayer)
	task.spawn(function()
		while TargetPlayer and TargetPlayer.Parent == Players do
			task.wait(0.1)

			local Character = Player.Character
			local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
			local RootPart = Humanoid and Humanoid.RootPart
			local TCharacter = TargetPlayer.Character
			local THumanoid = TCharacter and TCharacter:FindFirstChildOfClass("Humanoid")
			local TRootPart = THumanoid and THumanoid.RootPart
			local THead = TCharacter and TCharacter:FindFirstChild("Head")
			local Accessory = TCharacter and TCharacter:FindFirstChildOfClass("Accessory")
			local Handle = Accessory and Accessory:FindFirstChild("Handle")

			if not (Character and Humanoid and RootPart and TCharacter and THumanoid and TRootPart) then
				continue
			end

			-- Only fling if on the same level (ground check)
			if math.abs(TRootPart.Position.Y - RootPart.Position.Y) > 5 then
				continue
			end

			-- Save position
			if RootPart.Velocity.Magnitude < 50 then
				getgenv().OldPos = RootPart.CFrame
			end

			if THumanoid.Sit then
				continue
			end

			workspace.CurrentCamera.CameraSubject = THead or Handle or THumanoid

			local function FPos(BasePart, Pos, Ang)
				RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
				Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
				RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
				RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
			end

			local function SFBasePart(BasePart)
				local TimeToWait = 2
				local Time = tick()
				local Angle = 0
				repeat
					if RootPart and THumanoid then
						if BasePart.Velocity.Magnitude < 50 then
							Angle += 100
							FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
							task.wait()
							FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
							task.wait()
						else
							FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
							task.wait()
						end
					else
						break
					end
				until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TCharacter or TargetPlayer.Parent ~= Players or Humanoid.Health <= 0 or tick() > Time + TimeToWait
			end

			workspace.FallenPartsDestroyHeight = 0 / 0
			local BV = Instance.new("BodyVelocity")
			BV.Name = "EpixVel"
			BV.Parent = RootPart
			BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
			BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

			if TRootPart and THead then
				if (TRootPart.Position - THead.Position).Magnitude > 5 then
					SFBasePart(THead)
				else
					SFBasePart(TRootPart)
				end
			elseif TRootPart then
				SFBasePart(TRootPart)
			elseif THead then
				SFBasePart(THead)
			elseif Handle then
				SFBasePart(Handle)
			end

			BV:Destroy()
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
			workspace.CurrentCamera.CameraSubject = Humanoid

			repeat
				RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
				Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
				Humanoid:ChangeState("GettingUp")
				for _, x in ipairs(Character:GetChildren()) do
					if x:IsA("BasePart") then
						x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
					end
				end
				task.wait()
			until (RootPart.Position - getgenv().OldPos.Position).Magnitude < 25

			workspace.FallenPartsDestroyHeight = getgenv().FPDH
		end
	end)
end

-- Rayfield input field
local Input = Tab:CreateInput({
	Name = "User fling",
	CurrentValue = "",
	PlaceholderText = "UserName/DisplayName",
	RemoveTextAfterFocusLost = true,
	Flag = "Input1",
	Callback = function(Text)
		local targetPlayer = GetPlayer(Text)
		if targetPlayer then
			SkidFling(targetPlayer)
		else
			Message("Error Occurred", "Invalid username or display name", 5)
		end
	end
})

local TargetInput = Tab:CreateInput({
    Name = "Target Name",
    PlaceholderText = "Enter target name",
    RemoveTextAfterFocusLost = false,
    Callback = function(targetName)
        -- Store the input target name
        TargetName = targetName
    end
})

local ToggleButton = Tab:CreateButton({
    Name = "Start Following",
    Callback = function()
        if not following then
            -- Start following
            local targetName = TargetName:lower()
            targetPlayer = nil

            for _, player in pairs(Players:GetPlayers()) do
                if player.Name:lower():find(targetName) or player.DisplayName:lower():find(targetName) then
                    targetPlayer = player
                    break
                end
            end

            if targetPlayer and targetPlayer.Character then
                following = true
                Rayfield:Notify({
                    Title = "Following Started",
                    Content = "Now following " .. targetPlayer.Name,
                    Duration = 5,
                    Image = 4483362458,
                })

                -- Play Animation
                local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local animation = Instance.new("Animation")
                    animation.AnimationId = "rbxassetid://" .. animationId
                    activeAnimation = humanoid:LoadAnimation(animation)
                    activeAnimation:Play()
                end

                coroutine.wrap(function()
                    while following do
                        local targetCharacter = targetPlayer.Character
                        if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
                            local targetHRP = targetCharacter.HumanoidRootPart
                            local forwardCFrame = targetHRP.CFrame * CFrame.new(0, 0, -2.5)
                            local backwardCFrame = targetHRP.CFrame * CFrame.new(0, 0, -1.3)

                            local tweenForward = TweenService:Create(
                                LocalPlayer.Character:FindFirstChild("HumanoidRootPart"),
                                TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
                                {CFrame = forwardCFrame}
                            )
                            tweenForward:Play()
                            tweenForward.Completed:Wait()

                            local tweenBackward = TweenService:Create(
                                LocalPlayer.Character:FindFirstChild("HumanoidRootPart"),
                                TweenInfo.new(0.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
                                {CFrame = backwardCFrame}
                            )
                            tweenBackward:Play()
                            tweenBackward.Completed:Wait()
                        else
                            following = false
                            Rayfield:Notify({
                                Title = "Following Stopped",
                                Content = "Target is no longer valid.",
                                Duration = 5,
                                Image = 4483362458,
                            })
                            break
                        end
                    end
                end)()
            else
                Rayfield:Notify({
                    Title = "Target Not Found",
                    Content = "Could not find the target player.",
                    Duration = 5,
                    Image = 4483362458,
                })
            end
        else
            -- Stop following
            following = false
            Rayfield:Notify({
                Title = "Following Stopped",
                Content = "You have stopped following the target.",
                Duration = 5,
                Image = 4483362458,
            })

            -- Stop Animation
            if activeAnimation then
                activeAnimation:Stop()
                activeAnimation = nil
            end
        end
    end
})

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

local following = false
local targetPlayer = nil
local animationId = "189854234"
local activeAnimation = nil
local targetName = ""

-- Rayfield Toggle for Follow
Tab:CreateToggle({
    Name = "Follow Target",
    CurrentValue = false,
    Callback = function(Value)
        following = Value

        if following then
            -- Start following
            local name = targetName:lower()
            targetPlayer = nil

            -- Find the target player
            for _, player in pairs(Players:GetPlayers()) do
                if player.Name:lower():find(name) or player.DisplayName:lower():find(name) then
                    targetPlayer = player
                    break
                end
            end

            if targetPlayer and targetPlayer.Character then
                -- Play Animation
                local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local animation = Instance.new("Animation")
                    animation.AnimationId = "rbxassetid://" .. animationId
                    activeAnimation = humanoid:LoadAnimation(animation)
                    activeAnimation:Play()
                end

                -- Start moving toward the target
                coroutine.wrap(function()
                    while following do
                        local targetCharacter = targetPlayer.Character
                        if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
                            local targetHRP = targetCharacter.HumanoidRootPart
                            local forwardCFrame = targetHRP.CFrame * CFrame.new(0, 0, -2.5)
                            local backwardCFrame = targetHRP.CFrame * CFrame.new(0, 0, -1.3)

                            -- Move forward
                            local tweenForward = TweenService:Create(
                                LocalPlayer.Character:FindFirstChild("HumanoidRootPart"),
                                TweenInfo.new(0.15, Enum.EasingStyle.Linear),
                                {CFrame = forwardCFrame}
                            )
                            tweenForward:Play()
                            tweenForward.Completed:Wait()

                            -- Move backward
                            local tweenBackward = TweenService:Create(
                                LocalPlayer.Character:FindFirstChild("HumanoidRootPart"),
                                TweenInfo.new(0.15, Enum.EasingStyle.Linear),
                                {CFrame = backwardCFrame}
                            )
                            tweenBackward:Play()
                            tweenBackward.Completed:Wait()
                        else
                            following = false
                            if activeAnimation then
                                activeAnimation:Stop()
                                activeAnimation = nil
                            end
                            break
                        end
                    end
                end)()
            else
                -- Notify if target is not found or invalid
                Rayfield:Notify({
                    Title = "Error",
                    Content = "Target not found or invalid.",
                    Duration = 4
                })
            end
        else
            -- Stop following
            following = false
            if activeAnimation then
                activeAnimation:Stop()
                activeAnimation = nil
            end
        end
    end,
})

-- Rayfield Input for Target Name
Tab:CreateInput({
    Name = "Target Player",
    PlaceholderText = "Enter target name",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        targetName = Text
    end,
})

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

local following = false
local targetPlayer = nil
local animationId = "189854234"
local activeAnimation = nil
local targetName = ""

-- Tab Toggle for Follow
Tab:CreateToggle({
    Name = "Follow Target",
    CurrentValue = false,
    Callback = function(Value)
        following = Value

        if following then
            -- Start following
            local name = targetName:lower()
            targetPlayer = nil

            -- Find the target player by matching the first few letters of their name or display name
            for _, player in pairs(Players:GetPlayers()) do
                if player.Name:lower():sub(1, #name) == name or player.DisplayName:lower():sub(1, #name) == name then
                    targetPlayer = player
                    break
                end
            end

            if targetPlayer and targetPlayer.Character then
                -- Play Animation
                local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local animation = Instance.new("Animation")
                    animation.AnimationId = "rbxassetid://" .. animationId
                    activeAnimation = humanoid:LoadAnimation(animation)
                    activeAnimation:Play()
                end

                -- Start moving toward the target
                coroutine.wrap(function()
                    while following do
                        local targetCharacter = targetPlayer.Character
                        if targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
                            local targetHRP = targetCharacter.HumanoidRootPart
                            local forwardCFrame = targetHRP.CFrame * CFrame.new(0, 0, -2.5)
                            local backwardCFrame = targetHRP.CFrame * CFrame.new(0, 0, -1.3)

                            -- Move forward
                            local tweenForward = TweenService:Create(
                                LocalPlayer.Character:FindFirstChild("HumanoidRootPart"),
                                TweenInfo.new(0.15, Enum.EasingStyle.Linear),
                                {CFrame = forwardCFrame}
                            )
                            tweenForward:Play()
                            tweenForward.Completed:Wait()

                            -- Move backward
                            local tweenBackward = TweenService:Create(
                                LocalPlayer.Character:FindFirstChild("HumanoidRootPart"),
                                TweenInfo.new(0.15, Enum.EasingStyle.Linear),
                                {CFrame = backwardCFrame}
                            )
                            tweenBackward:Play()
                            tweenBackward.Completed:Wait()
                        else
                            following = false
                            if activeAnimation then
                                activeAnimation:Stop()
                                activeAnimation = nil
                            end
                            break
                        end
                    end
                end)()
            else
                -- Notify if target is not found or invalid
                Tab:Notify({
                    Title = "Error",
                    Content = "Target not found or invalid.",
                    Duration = 4
                })
            end
        else
            -- Stop following
            following = false
            if activeAnimation then
                activeAnimation:Stop()
                activeAnimation = nil
            end
        end
    end,
})

-- Tab Input for Target Name
Tab:CreateInput({
    Name = "Target Player",
    PlaceholderText = "Enter target name",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        targetName = Text
    end,
})
local scriptRunning = false
local undoFunction

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

local TELEPORT_DISTANCE = 3
local hitboxPart = nil
local toggleEnabled = false -- Toggle state

-- Function to find the nearest player
local function getNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = math.huge
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                nearestPlayer = player
                shortestDistance = distance
            end
        end
    end
    return nearestPlayer
end

-- Function to handle touch events and teleport the local player away
local function onHitboxTouched(otherPart)
    if toggleEnabled and Character and otherPart:IsDescendantOf(Character) then
        -- Calculate teleport direction and position
        local direction = (HumanoidRootPart.Position - hitboxPart.Position).unit
        local newPosition = HumanoidRootPart.Position + direction * TELEPORT_DISTANCE

        -- Teleport player using CFrame
        HumanoidRootPart.CFrame = CFrame.new(newPosition)
    end
end

-- Function to create/remove hitbox based on "HoldingM1" attribute
local function updateHitboxForPlayer(player)
    local liveFolder = Workspace:FindFirstChild("Live")
    if liveFolder then
        local playerModel = liveFolder:FindFirstChild(player.Name)
        if playerModel then
            local holdingM1 = playerModel:GetAttribute("HoldingM1")
            if holdingM1 == true then
                -- Create or update the hitbox part
                if not hitboxPart then
                    hitboxPart = Instance.new("Part")
                    hitboxPart.Anchored = true
                    hitboxPart.CanCollide = false
                    hitboxPart.Transparency = 0.5
                    hitboxPart.BrickColor = BrickColor.new("Bright red")
                    hitboxPart.Touched:Connect(onHitboxTouched) -- Connect the Touched event
                    hitboxPart.Parent = Workspace
                end
                local targetHumanoidRootPart = player.Character.HumanoidRootPart
                hitboxPart.Size = targetHumanoidRootPart.Size + Vector3.new(10, 10, 10) -- Make the hitbox significantly larger
                hitboxPart.Position = targetHumanoidRootPart.Position -- Align hitbox with the player's position
            else
                -- Remove the hitbox if "HoldingM1" is false
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                end
            end
        end
    end
end

-- Main loop
RunService.Heartbeat:Connect(function()
    if toggleEnabled then
        local nearestPlayer = getNearestPlayer()
        if nearestPlayer then
            updateHitboxForPlayer(nearestPlayer) -- Check the "HoldingM1" attribute and update the hitbox
        else
            -- Remove the hitbox if no nearest player is found
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    else
        -- Remove the hitbox if the toggle is disabled
        if hitboxPart then
            hitboxPart:Destroy()
            hitboxPart = nil
        end
    end
end)

-- Rayfield Toggle
local Toggle = Tab:CreateToggle({
    Name = "Enable Hitbox and Teleport",
    CurrentValue = false, -- Default state of the toggle
    Flag = "HitboxTeleportToggle", -- Unique identifier for configuration saving
    Callback = function(Value)
        toggleEnabled = Value -- Update the toggle state
    end,
})
local Slider = Tab:CreateSlider({
   Name = "teleport distance",
   Range = {0, 30},
   Increment = 2,
   Suffix = "feet",
   CurrentValue = 3,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)

 TELEPORT_DISTANCE = Value

   -- The function that takes place when the slider changes
   -- The variable (Value) is a number which correlates to the value the slider is currently at
   end,
})
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

local TELEPORT_DISTANCE = 3
local hitboxPart = nil
local toggleEnabled = false -- Toggle state

-- Function to find the nearest player
local function getNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = math.huge
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                nearestPlayer = player
                shortestDistance = distance
            end
        end
    end
    return nearestPlayer
end

-- Function to handle touch events and teleport the local player away
local function onHitboxTouched(otherPart)
    if toggleEnabled and Character and otherPart:IsDescendantOf(Character) then
        -- Calculate teleport direction and position
        local direction = (HumanoidRootPart.Position - hitboxPart.Position).unit
        local newPosition = HumanoidRootPart.Position + direction * TELEPORT_DISTANCE

        -- Teleport player using CFrame
        HumanoidRootPart.CFrame = CFrame.new(newPosition)
    end
end

-- Function to create/remove hitbox based on "HoldingM1" attribute
local function updateHitboxForPlayer(player)
    local liveFolder = Workspace:FindFirstChild("Live")
    if liveFolder then
        local playerModel = liveFolder:FindFirstChild(player.Name)
        if playerModel then
            local holdingM1 = playerModel:GetAttribute("HoldingM1")
            if holdingM1 == true then
                -- Create or update the hitbox part
                if not hitboxPart then
                    hitboxPart = Instance.new("Part")
                    hitboxPart.Anchored = true
                    hitboxPart.CanCollide = false
                    hitboxPart.Transparency = 0.8
                    hitboxPart.BrickColor = BrickColor.new("Bright red")
                    hitboxPart.Touched:Connect(onHitboxTouched) -- Connect the Touched event
                    hitboxPart.Parent = Workspace
                end
                local targetHumanoidRootPart = player.Character.HumanoidRootPart
                hitboxPart.Size = targetHumanoidRootPart.Size + Vector3.new(10, 10, 10) -- Make the hitbox significantly larger
                hitboxPart.Position = targetHumanoidRootPart.Position -- Align hitbox with the player's position
            else
                -- Ensure the hitbox is destroyed if "HoldingM1" is false
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                end
            end
        else
            -- Ensure the hitbox is destroyed if player's model is not found
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    else
        -- Ensure the hitbox is destroyed if "Live" folder is not found
        if hitboxPart then
            hitboxPart:Destroy()
            hitboxPart = nil
        end
    end
end

-- Main loop
RunService.Heartbeat:Connect(function()
    if toggleEnabled then
        local nearestPlayer = getNearestPlayer()
        if nearestPlayer then
            updateHitboxForPlayer(nearestPlayer) -- Check the "HoldingM1" attribute and update the hitbox
        else
            -- Ensure the hitbox is destroyed if no nearest player is found
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    else
        -- Ensure the hitbox is destroyed if the toggle is disabled
        if hitboxPart then
            hitboxPart:Destroy()
            hitboxPart = nil
        end
    end
end)

-- Rayfield Toggle
local Toggle = Tab:CreateToggle({
    Name = "Enable Hitbox and Teleport",
    CurrentValue = false, -- Default state of the toggle
    Flag = "HitboxTeleportToggle", -- Unique identifier for configuration saving
    Callback = function(Value)
        toggleEnabled = Value -- Update the toggle state
    end,
})

local Slider = Tab:CreateSlider({
   Name = "teleport distance",
   Range = {0, 30},
   Increment = 2,
   Suffix = "feet",
   CurrentValue = 3,
   Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)

 TELEPORT_DISTANCE = Value

   -- The function that takes place when the slider changes
   -- The variable (Value) is a number which correlates to the value the slider is currently at
   end,
})
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local toggleEnabled = false -- Toggle state
local teleportMethod = "Tween" -- Default teleport method

-- Function encapsulating all the logic
local function HitboxAndTeleportLogic()
    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

    local TELEPORT_DISTANCE = 20
    local hitboxPart = nil

    -- Function to find the nearest player
    local function getNearestPlayer()
        local nearestPlayer = nil
        local shortestDistance = math.huge
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    nearestPlayer = player
                    shortestDistance = distance
                end
            end
        end
        return nearestPlayer
    end

    -- Function to handle touch events and teleport the local player away
    local function onHitboxTouched(otherPart)
        if toggleEnabled and Character and otherPart:IsDescendantOf(Character) then
            -- Calculate teleport direction and position
            local direction = (HumanoidRootPart.Position - hitboxPart.Position).Unit
            local newPosition = HumanoidRootPart.Position + direction * TELEPORT_DISTANCE

            if teleportMethod == "CFrame" then
                -- Instantly teleport using CFrame
                HumanoidRootPart.CFrame = CFrame.new(newPosition)
            elseif teleportMethod == "Tween" then
                -- Smoothly teleport using Tween
                local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
                local goal = {CFrame = CFrame.new(newPosition)}
                local tween = TweenService:Create(HumanoidRootPart, tweenInfo, goal)
                tween:Play()
            end
        end
    end

    -- Function to create/remove hitbox based on the presence of an "M1ing" accessory
    local function updateHitboxForPlayer(player)
        local liveFolder = Workspace:FindFirstChild("Live")
        if liveFolder then
            local playerModel = liveFolder:FindFirstChild(player.Name)
            if playerModel then
                -- Continuously check for the "M1ing" accessory
                local m1ingAccessory = playerModel:FindFirstChild("M1ing")
                if not m1ingAccessory then
                    for i = 1, 10 do -- Wait up to 1 second
                        task.wait(0.1)
                        m1ingAccessory = playerModel:FindFirstChild("M1ing")
                        if m1ingAccessory then
                            break
                        end
                    end
                end

                if m1ingAccessory and m1ingAccessory:IsA("Accessory") then
                    -- Create or update the hitbox part
                    if not hitboxPart then
                        hitboxPart = Instance.new("Part")
                        hitboxPart.Anchored = true
                        hitboxPart.CanCollide = false
                        hitboxPart.Transparency = 0.5
                        hitboxPart.BrickColor = BrickColor.new("Bright red")
                        hitboxPart.Touched:Connect(onHitboxTouched)
                        hitboxPart.Parent = Workspace
                    end
                    local targetHumanoidRootPart = player.Character.HumanoidRootPart
                    hitboxPart.Size = targetHumanoidRootPart.Size + Vector3.new(10, 10, 10)
                    hitboxPart.Position = targetHumanoidRootPart.Position
                else
                    if hitboxPart then
                        hitboxPart:Destroy()
                        hitboxPart = nil
                    end
                end
            else
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                end
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if toggleEnabled then
            local nearestPlayer = getNearestPlayer()
            if nearestPlayer then
                updateHitboxForPlayer(nearestPlayer)
            else
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                end
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    end)
end

-- Rayfield Toggle
local Toggle = Tab:CreateToggle({
    Name = "Enable Hitbox and Teleport (Accessory Check)",
    CurrentValue = false,
    Flag = "HitboxTeleportAccessoryToggle",
    Callback = function(Value)
        toggleEnabled = Value
        if Value then
            HitboxAndTeleportLogic()
        end
    end,
})

-- Rayfield Dropdown
local Dropdown = Tab:CreateDropdown({
    Name = "Teleport Method",
    Options = {"CFrame", "Tween"},
    CurrentOption = "Tween",
    Flag = "TeleportMethodDropdown",
    Callback = function(Option)
        teleportMethod = Option
    end,
})
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local toggleEnabled = false -- Toggle state
local teleportMethod = "Tween" -- Default teleport method

-- Function encapsulating all the logic
local function HitboxAndTeleportLogic()
    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

    local TELEPORT_DISTANCE = 20
    local hitboxPart = nil

    -- Function to find the nearest player
    local function getNearestPlayer()
        local nearestPlayer = nil
        local shortestDistance = math.huge
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    nearestPlayer = player
                    shortestDistance = distance
                end
            end
        end
        return nearestPlayer
    end

    -- Function to handle touch events and teleport the local player away
    local function onHitboxTouched(otherPart)
        if toggleEnabled and Character and otherPart:IsDescendantOf(Character) then
            -- Calculate teleport direction and position
            local direction = (HumanoidRootPart.Position - hitboxPart.Position).Unit
            local newPosition = HumanoidRootPart.Position + direction * TELEPORT_DISTANCE

            if teleportMethod == "CFrame" then
                -- USE your original CFrame teleport code (no tween)
                HumanoidRootPart.CFrame = CFrame.new(newPosition)
            elseif teleportMethod == "Tween" then
                -- Tween teleport
                local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
                local goal = {CFrame = CFrame.new(newPosition)}
                local tween = TweenService:Create(HumanoidRootPart, tweenInfo, goal)
                tween:Play()
            end
        end
    end

    -- Function to create/remove hitbox based on the presence of an "M1ing" accessory
    local function updateHitboxForPlayer(player)
        local liveFolder = Workspace:FindFirstChild("Live")
        if liveFolder then
            local playerModel = liveFolder:FindFirstChild(player.Name)
            if playerModel then
                local m1ingAccessory = playerModel:FindFirstChild("M1ing")
                if not m1ingAccessory then
                    for i = 1, 10 do
                        task.wait(0.1)
                        m1ingAccessory = playerModel:FindFirstChild("M1ing")
                        if m1ingAccessory then
                            break
                        end
                    end
                end

                if m1ingAccessory and m1ingAccessory:IsA("Accessory") then
                    if not hitboxPart then
                        hitboxPart = Instance.new("Part")
                        hitboxPart.Anchored = true
                        hitboxPart.CanCollide = false
                        hitboxPart.Transparency = 0.5
                        hitboxPart.BrickColor = BrickColor.new("Bright red")
                        hitboxPart.Touched:Connect(onHitboxTouched)
                        hitboxPart.Parent = Workspace
                    end
                    local targetHumanoidRootPart = player.Character.HumanoidRootPart
                    hitboxPart.Size = targetHumanoidRootPart.Size + Vector3.new(10, 10, 10)
                    hitboxPart.Position = targetHumanoidRootPart.Position
                else
                    if hitboxPart then
                        hitboxPart:Destroy()
                        hitboxPart = nil
                    end
                end
            else
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                end
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if toggleEnabled then
            local nearestPlayer = getNearestPlayer()
            if nearestPlayer then
                updateHitboxForPlayer(nearestPlayer)
            else
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                end
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
            end
        end
    end)
end

-- Rayfield Toggle
local Toggle = Tab:CreateToggle({
    Name = "Enable Hitbox and Teleport (Accessory Check)",
    CurrentValue = false,
    Flag = "HitboxTeleportAccessoryToggle",
    Callback = function(Value)
        toggleEnabled = Value
        if Value then
            HitboxAndTeleportLogic()
        end
    end,
})

-- Rayfield Dropdown
local Dropdown = Tab:CreateDropdown({
    Name = "Teleport Method",
    Options = {"CFrame", "Tween"},
    CurrentOption = "Tween",
    Flag = "TeleportMethodDropdown",
    Callback = function(Option)
        teleportMethod = Option
    end,
})
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local toggleEnabled = false
local teleportMethod = "Tween"
local hitboxPart
local hitboxConnection

-- Function to refresh hitbox touch event
local function connectHitboxTouch(Character, HumanoidRootPart)
    if hitboxConnection then
        hitboxConnection:Disconnect()
        hitboxConnection = nil
    end

    hitboxConnection = hitboxPart.Touched:Connect(function(otherPart)
        if toggleEnabled and Character and otherPart:IsDescendantOf(Character) then
            local direction = (HumanoidRootPart.Position - hitboxPart.Position).Unit
            local newPosition = HumanoidRootPart.Position + direction * 20 -- TELEPORT_DISTANCE = 20

            if teleportMethod == "CFrame" then
                HumanoidRootPart.CFrame = CFrame.new(newPosition)
            elseif teleportMethod == "Tween" then
                local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
                local goal = {CFrame = CFrame.new(newPosition)}
                local tween = TweenService:Create(HumanoidRootPart, tweenInfo, goal)
                tween:Play()
            end
        end
    end)
end

-- Function encapsulating all the logic
local function HitboxAndTeleportLogic()
    local LocalPlayer = Players.LocalPlayer
    local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

    -- Function to find the nearest player
    local function getNearestPlayer()
        local nearestPlayer = nil
        local shortestDistance = math.huge
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    nearestPlayer = player
                    shortestDistance = distance
                end
            end
        end
        return nearestPlayer
    end

    -- Function to create/remove hitbox based on M1ing
    local function updateHitboxForPlayer(player)
        local liveFolder = Workspace:FindFirstChild("Live")
        if liveFolder then
            local playerModel = liveFolder:FindFirstChild(player.Name)
            if playerModel then
                local m1ingAccessory = playerModel:FindFirstChild("M1ing")
                if not m1ingAccessory then
                    for i = 1, 10 do
                        task.wait(0.1)
                        m1ingAccessory = playerModel:FindFirstChild("M1ing")
                        if m1ingAccessory then
                            break
                        end
                    end
                end

                if m1ingAccessory and m1ingAccessory:IsA("Accessory") then
                    if not hitboxPart then
                        hitboxPart = Instance.new("Part")
                        hitboxPart.Anchored = true
                        hitboxPart.CanCollide = false
                        hitboxPart.Transparency = 0.5
                        hitboxPart.BrickColor = BrickColor.new("Bright red")
                        hitboxPart.Parent = Workspace
                        connectHitboxTouch(Character, HumanoidRootPart) -- Connect touch here
                    end
                    local targetHumanoidRootPart = player.Character.HumanoidRootPart
                    hitboxPart.Size = targetHumanoidRootPart.Size + Vector3.new(10, 10, 10)
                    hitboxPart.Position = targetHumanoidRootPart.Position
                else
                    if hitboxPart then
                        hitboxPart:Destroy()
                        hitboxPart = nil
                        if hitboxConnection then
                            hitboxConnection:Disconnect()
                            hitboxConnection = nil
                        end
                    end
                end
            else
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                    if hitboxConnection then
                        hitboxConnection:Disconnect()
                        hitboxConnection = nil
                    end
                end
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
                if hitboxConnection then
                    hitboxConnection:Disconnect()
                    hitboxConnection = nil
                end
            end
        end
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if toggleEnabled then
            local nearestPlayer = getNearestPlayer()
            if nearestPlayer then
                updateHitboxForPlayer(nearestPlayer)
            else
                if hitboxPart then
                    hitboxPart:Destroy()
                    hitboxPart = nil
                    if hitboxConnection then
                        hitboxConnection:Disconnect()
                        hitboxConnection = nil
                    end
                end
            end
        else
            if hitboxPart then
                hitboxPart:Destroy()
                hitboxPart = nil
                if hitboxConnection then
                    hitboxConnection:Disconnect()
                    hitboxConnection = nil
                end
            end
        end
    end)
end

-- Rayfield Toggle
local Toggle = Tab:CreateToggle({
    Name = "Enable Hitbox and Teleport (Accessory Check)",
    CurrentValue = false,
    Flag = "HitboxTeleportAccessoryToggle",
    Callback = function(Value)
        toggleEnabled = Value
        if Value then
            HitboxAndTeleportLogic()
        end
    end,
})

-- Rayfield Dropdown
local Dropdown = Tab:CreateDropdown({
    Name = "Teleport Method",
    Options = {"CFrame", "Tween"},
    CurrentOption = "Tween",
    Flag = "TeleportMethodDropdown",
    Callback = function(Option)
        teleportMethod = Option
        if hitboxPart then
            -- When changing method, refresh hitbox touch connection
            local LocalPlayer = Players.LocalPlayer
            local Character = LocalPlayer.Character
            if Character then
                local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
                if HumanoidRootPart then
                    connectHitboxTouch(Character, HumanoidRootPart)
                end
            end
        end
    end,
})
local autoparryEnabled = false
local camera = game:GetService("Workspace").CurrentCamera

-- Rayfield toggle setup
Tab:CreateToggle({
    Name = "Autoparry",
    CurrentValue = false,
    Callback = function(Value)
        autoparryEnabled = Value
    end,
})

-- Autoparry code
local players = game:GetService("Players")
local plr = players.LocalPlayer
local cd = false
local Settings = {
    Autoparry = { Toggle = true, Range = 11, Delay = 0, Fov = 360, Facing = false, Dodgerange = 3, Aimhelper = false },
}

local anims = {
    ["rbxassetid://10469493270"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://10469630950"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://10469639222"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://10469643643"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13532562418"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13532600125"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13532604085"] = { [1] = 0, [2] = 0.30 },
    ["rbxassetid://13294471966"] = { [1] = 0, [2] = 0.30 },
}

local dodges = {
    ["rbxassetid://10479335397"] = { [1] = 0, [2] = 0.50 }, 
    ["rbxassetid://13380255751"] = { [1] = 0, [2] = 0.50 }
}

local barrages = {
    ["rbxassetid://10466974800"] = { [1] = 0.20, [2] = 1.80 },
    ["rbxassetid://12534735382"] = { [1] = 0.20, [2] = 1.80 }
}

local abilities = {
    ["rbxassetid://10468665991"] = { [1] = 0.15, [2] = 0.60 },
    ["rbxassetid://13376869471"] = { [1] = 0.05, [2] = 1 },
    ["rbxassetid://13376962659"] = { [1] = 0, [2] = 2 },
}

local closestplr, anim, plrDirection, unit, value, dodge

function closest()
    closestplr = {}
    for i, v in next, players:GetChildren() do
        if v.Character and plr.Character:WaitForChild("HumanoidRootPart", 1) and v ~= plr and v.Character ~= plr.Character and v.Character:FindFirstChild("HumanoidRootPart")
            and (v.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude < Settings.Autoparry.Range
        then
            table.insert(closestplr, v)
        end
    end
    return closestplr
end

function attackchecker()
    for i, Anim in next, plr.Character.Humanoid.Animator:GetPlayingAnimationTracks() do
        z = anims[Anim.Animation.AnimationId] 
        q = dodges[Anim.Animation.AnimationId]
        j = abilities[Anim.Animation.AnimationId]
        k =  barrages[Anim.Animation.AnimationId]
        if z or q or j or k then  return true
        else return false
        end
    end
end

function isfacing(object)
    if Settings.Autoparry.Toggle then
        if Settings.Autoparry.Facing then
            plrDirection = plr.Character.Head.CFrame.LookVector
            unit = (object.Head.CFrame.p - plr.Character.Head.CFrame.p).Unit
            value = math.pow((plrDirection - unit).Magnitude / 2, 2)
            if value >= Settings.Autoparry.Fov / 360 then
                return false
            else
                return true
            end
        else
            return true
        end
    end
end 

function allowed(enemy)
    if not plr.Character:FindFirstChild("M1ing") and not attackchecker() and isfacing(enemy) then 
        return true
    end
end

local durations = {
    ["anim" ] = 0.3,
    ["dodge" ] = 0.9,
    ["barrage" ] = 0.9,
    ["ability" ] = 0.6,
}

function def(action)
    if cd then
        return
    end
    task.wait(Settings.Autoparry.Delay)
    print("parry attempt".."|"..action)
    cd = true
    plr.Character.Communicate:FireServer({["Goal"] = "KeyPress", ["Key"] = Enum.KeyCode.F})
    task.wait(durations[action])
    plr.Character.Communicate:FireServer({["Goal"] = "KeyRelease",["Key"] = Enum.KeyCode.F})
    cd = false
end

function barragechecker(enemy)
    if enemy:FindFirstChild("BarrageBind") then
        return true
    else
        return false
    end
end

function lookat(enemy)
    if Settings.Autoparry.Aimhelper then
        -- Lock the camera to the enemy while blocking
        camera.CFrame = CFrame.lookAt(plr.Character.HumanoidRootPart.Position, enemy.HumanoidRootPart.Position)
    end
end

function unlockCamera()
    -- Reset camera to its original position (optional: can use your own method for resetting)
    camera.CameraSubject = plr.Character.Humanoid
    camera.CFrame = plr.Character.HumanoidRootPart.CFrame
end

function parry()
    for i, c in closest() do
        if c and plr.Character:WaitForChild("HumanoidRootPart", 2) and c.Character and c.Character:FindFirstChild("Humanoid") and c.Character.Humanoid:FindFirstChild("Animator")
        then
            for i, v in next, c.Character.Humanoid.Animator:GetPlayingAnimationTracks() do
                anim = anims[v.Animation.AnimationId] 
                dodge = dodges[v.Animation.AnimationId]
                ability = abilities[v.Animation.AnimationId]
                barrage = barrages[v.Animation.AnimationId]
                if allowed(c.Character) and  anim  and v.TimePosition >= anim[1] and v.TimePosition <= anim[2] then
                    task.spawn(function()
                        def("anim")
                        lookat(c.Character)  -- Lock camera while parrying
                    end)
                elseif allowed(c.Character) and dodge  and v.TimePosition > dodge[1] and v.TimePosition < dodge[2]   then
                    task.spawn(function()
                        def("dodge")
                        lookat(c.Character)  -- Lock camera while dodging
                    end)
                elseif allowed(c.Character) and  barrage and v.TimePosition > barrage[1] and v.TimePosition < barrage[2]   then
                    task.spawn(function()
                        def("barrage")
                        lookat(c.Character)  -- Lock camera while barraging
                    end)
                elseif allowed(c.Character) and ability and v.TimePosition > ability[1] and v.TimePosition < ability[2]  then
                    task.spawn(function()
                        def("ability")
                        lookat(c.Character)  -- Lock camera while using ability
                    end)
                end
            end
        end
    end
end

task.spawn(function()
    game:GetService("RunService").RenderStepped:Connect(function()
        if autoparryEnabled then
            parry()
        else
            unlockCamera()  -- Unlock camera once parrying is disabled
        end
    end)
end)

warn("Executed")

